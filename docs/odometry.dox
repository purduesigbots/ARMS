/*! \page odometry Odometry Explanation
 * The ARMS implementation of odometry follows the <a href="https://wiki.purduesigbots.com/software/odometry">PiLons odometry algorithm</a>,
 * with a couple of modifications.
 * \section odometry_code Odometry Code
 * @code
 * int odomTask() {
 *
 *     position.x = 0;
 *     position.y = 0;
 *     heading = 0;
 *
 *     while (true) {
 *         // get positions of each encoder
 *         double left_pos = getLeftEncoder();
 *         double right_pos = getRightEncoder();
 *         double middle_pos = configData.middleEncoderPort ? getMiddleEncoder() : 0;
 *
 *         // calculate change in each encoder
 *         double delta_left = (left_pos - prev_left_pos) / tpi;
 *         double delta_right = (right_pos - prev_right_pos) / tpi;
 *         double delta_middle = configData.middleEncoderPort
 *                                 ? (middle_pos - prev_middle_pos) / middle_tpi
 *                                 : 0;
 *
 *         // calculate new heading
 *         double delta_angle;
 *         if (imu) {
 *             heading = -imu->get_rotation() * M_PI / 180.0;
 *             delta_angle = heading - prev_heading;
 *         } else {
 *             delta_angle = (delta_right - delta_left) / track_width;
 *
 *             heading += delta_angle;
 *         }
 *
 *         // store previous positions
 *         prev_left_pos = left_pos;
 *         prev_right_pos = right_pos;
 *         prev_middle_pos = middle_pos;
 *         prev_heading = heading;
 *
 *         // calculate local displacement
 *         double local_x;
 *         double local_y;
 *
 *         if (delta_angle) {
 *             double i = sin(delta_angle / 2.0) * 2.0;
 *             local_x = (delta_right / delta_angle - left_right_distance) * i;
 *             local_y = (delta_middle / delta_angle + middle_distance) * i;
 *         } else {
 *             local_x = delta_right;
 *             local_y = delta_middle;
 *         }
 *
 *         double p = heading - delta_angle / 2.0; // global angle
 *
 *         // convert to absolute displacement
 *         position.x += cos(p) * local_x + sin(p) * local_y;
 *         position.y += cos(p) * local_y + sin(p) * local_x;
 *
 *         if (debug)
 *             printf("%.2f, %.2f, %.2f \n", position.x, position.y, getHeading());
 *
 *         pros::delay(10);
 *     }
 * }
 * @endcode
 */